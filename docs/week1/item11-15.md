# 📂 [Week 1] Item 11~15: 타입 설계와 중복 제거

---

## 🏷️ Metadata

학습일: 2025년 12월 22일

주차: #Week1

키워드: #TypeScript #잉여속성체크 #함수표현식 #DRY #타입설계

---

## 🚀 핵심 요약

> [!abstract] 이 섹션의 핵심 한 줄
>
> (이곳에 아이템 11~15를 아우르는 핵심 인사이트를 한 줄로 정리해 보세요.)

---

## ✍️ 주요 내용 정리

### Item 11. 잉여 속성 체크의 한계 인지하기
- 변수에 직접 타입을 지정하면 오류를 찾아내지만, 임시 변수에 타입을 지정하면 부분집합이므로 타입 체커에 통과된다.
  - 전자는 구조적 타입 시스템에서 발생할 수 있는 잉여 속성 체크가 수행된다. 
  - 잉여 체크 검사가 할당 가능 검사와는 별도 과정이다. (Mental Model == 심성 모형)
- 객체 리터럴을 변수나 함수의 매게변수에 전달할 때 잉여 속성 체크가 수행된다. 
- 의도와 다르게 작성된 코드를 찾으려 한다.
  - darkMode 라는 타입과 darkmode 라는 속성 오탈자를 찾으려 한다. 
  - document 라는 객체와 new HTMLAnchorElement 에는 title 이라는 속성이 있어 정상이다.
  - '엄격한 객체 리터럴 체크' 를 통해 방지가 가능하다. : 
- 잉여 속성 체크는 단언문(타입 케스팅)에서도 적용되지 않는다.
- 잉야 속성 체크를 원하지 않을 경우, 인덱스 시그니처(컨트릭트)를 사용해 추가 속성을 예상할 수 있다.
- 임시 상수를 도입하름오러 잉여 속성 체크의 문제를 해결한다. 
  - 문맥 관점의 오류는 #Item26 에서 다룬다.
- 타입스크립트 타입 체커가 수행하는 '일반적인 구조적 할당 가능성 체크'와 역할이 다르다.
  - 잉여 속성 체크 vs 일반적인 구조적 할당 가능성 체크 ==> 차이를 구분할 줄 알아야 한다. 
- 공통 속성 체크 : 잉여 속성 체크와 동일하게 오타를 잡는데 좋다. (구체적 예제는 #Item18)

### Item 12. 함수 표현식에 타입 적용하기
```ts
function rollDice1(sides: number): number {..} // 함수 선언문 Function Declaration (또는 Function Statement)
const rollDice2 = function(sides: number): number {..} // 함수 표현식 (Function Expression)
const rollDice3 = (sides: number): number => {..} // 화살표 함수 (Arrow Function)
```

- 함수 문장 (statement) :
- 함수 표현식 (expression) :
- 함수 타입 선언의 장점
  - 불필요한 코드의 반복을 줄인다.
- 시그니처가 일치하는 다른 함수가 있을 때 함수 표현식에 타입을 적용할 수 있다.
  - 디자인패턴 (래퍼 패턴, 데코레이터 패턴, 프록시 패턴 등)을 적용할 수 있다.
  - fetch 는 일반적으로 Error Handling Decorator 인터셉터로 따로 구현을 하긴 한다.
  - Error Handling Decorator 을 위한 목적으로라도 인터셉터를 따로 만드는게 일반적인 것 같다
  - 관심사 분리가능
  - 함수 전체의 타입 선언을 적용해야한다.
- 타입을 계속 만들다기보단 이미 존재하는 타입을 찾아보도록 해야한다.
- 라이브러리를 직접 만든다면 공통 콜백 타입을 제공해야 한다.
- 다른 함수의 시그니처(컨트릭트)를 참고하려면 typeof fn 을 사용하면 된다.
```ts
// 내장 함수인 fetch의 타입을 그대로 가져온다.
// T: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>
type FetchFn = typeof fetch;

const monitoredFetch: FetchFn = async (input, init) => {
  const start = Date.now();
  
  try {
    const response = await fetch(input, init);
    const duration = Date.now() - start;
    console.log(`소요 시간: ${duration}ms`);
    return response;
  } catch (e) {
    console.error('에러:', e);
    throw e;
  }
};
```
- 함수 시그니처를 복사할 때 typeof를 사용하면, 원본 함수의 인터페이스를 그대로 계승하면서 로직만 살짝 바꾸는 래퍼(Wrapper)나 프록시(Proxy) 를 만들 때 타입 안전성을 유지할 수 있다.
  - 떄문에 외부 라이브러리를 사용할땐 패터나 프록시 패턴 등을 이용하면 유지보수에 좋다.  

### Item 13. 타입과 인터페이스의 차이점 알기

### Item 14. 타입 연산과 제네릭 사용으로 반복 줄이기

### Item 15. 동적 데이터에 인덱스 시그니처 사용하기

---

## 💻 코드 예시

**❌ 지양해야 할 코드**

TypeScript

```
// 이곳에 타입 단언이나 객체 래퍼 타입 사용 등 좋지 않은 예시를 작성하세요.

```

**✅ 지향해야 할 코드**

TypeScript

```
// 이곳에 타입 선언이나 집합론적 관점이 잘 드러난 안전한 코드를 작성하세요.

```
